(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{584:function(t,_,v){"use strict";v.r(_);var a=v(4),l=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"_1-http基础知识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-http基础知识"}},[t._v("#")]),t._v(" 1. HTTP基础知识")]),t._v(" "),v("h3",{attrs:{id:"_1-http是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-http是什么"}},[t._v("#")]),t._v(" 1. HTTP是什么？")]),t._v(" "),v("p",[t._v("HTTP是超文本传输协议，HyperText Transfer Protocol。")]),t._v(" "),v("p",[t._v("HTTP可以被拆成三部分：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://src.zk123.top//md/9f222b36-b89c-4244-adba-940b154a2c9a-3807603.png",alt:"9f222b36-b89c-4244-adba-940b154a2c9a-3807603"}})]),t._v(" "),v("ol",[v("li",[t._v("协议")])]),t._v(" "),v("blockquote",[v("ul",[v("li",[t._v("HTTP是一个用于计算机世界中的协议，它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。")])])]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("传输")])]),t._v(" "),v("blockquote",[v("ul",[v("li",[v("p",[t._v("所谓的传输，就是把一堆东西从A点搬到B点，或者从B点搬到A点。")])]),t._v(" "),v("li",[v("p",[t._v("这个简单的动作可见：HTTP协议是一个双向协议")])]),t._v(" "),v("li",[v("p",[t._v("网上冲浪时，浏览器是请求方A，网站是应答方B。双方约定HTTP协议来通信，于是浏览器把请求的数据发送给网站，网站再把一些数据再返回给浏览器，最后由浏览器选在在屏幕上，就能够看到图片、视频了。")])]),t._v(" "),v("li",[v("p",[t._v("数据虽然是在A和B之间传输，但允许中间有中转或者接力。")])])])]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("超文本")])]),t._v(" "),v("blockquote",[v("ul",[v("li",[v("p",[t._v("HTTP传输的内容是"),v("strong",[t._v("超文本")])])]),t._v(" "),v("li",[v("p",[t._v("我们先理解"),v("strong",[t._v("文本")]),t._v("，在互联网早期时，文本只是简单的字符，但现在文本的内涵已经可以扩展为图片、视频、压缩包等。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("超文本")]),t._v("就是超越了普通文本的文本，它是文字、图片、视频等的混合体，最为关键的是具有"),v("strong",[t._v("超链接")]),t._v("，能够从一个超文本跳转到另一个超文本。")])]),t._v(" "),v("li",[v("p",[t._v("HTML是最常见的超文本，他本是只是纯文字文件，但内部使用多标签定义了图片，视频等的链接，在经过浏览器的解释，呈现给我们的就是一个有文字、画面的网页了。")])])])]),t._v(" "),v("p",[t._v("总结：HTTP是一个在计算机世界中专门在两点之间传输文字、图片、视频等超文本数据的"),v("strong",[t._v("约定和规范")]),t._v("。")]),t._v(" "),v("h2",{attrs:{id:"_2-http常见状态码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-http常见状态码"}},[t._v("#")]),t._v(" 2. HTTP常见状态码")]),t._v(" "),v("h3",{attrs:{id:"_1xx"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1xx"}},[t._v("#")]),t._v(" 1XX")]),t._v(" "),v("ul",[v("li",[t._v("属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。")])]),t._v(" "),v("h3",{attrs:{id:"_2xx"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2xx"}},[t._v("#")]),t._v(" 2XX")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("2XX状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("200 OK")]),t._v(" 是最常见的成功状态码，表示一切正常。如果是非HEAD请求，服务器返回的响应头都会有body数据。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("204 No Content")]),t._v(" 也是常见的成功状态码，与200 OK基本相同，但是响应头没有body数据。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("206 Partial Content")]),t._v(" 是应用于HTTP分块下载或断电续传，表示响应返回的body数据并不是资源的全部，只是其中的一部分，也是服务器处理成功的状态。")])])]),t._v(" "),v("h3",{attrs:{id:"_3xx"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3xx"}},[t._v("#")]),t._v(" 3XX")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("3XX")]),t._v(" 类状态码表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，也就是"),v("a",{attrs:{href:"https://baike.baidu.com/item/%E9%87%8D%E5%AE%9A%E5%90%91/9064196?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[t._v("重定向"),v("OutboundLink")],1),t._v("。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("301 Moved Permanently")]),t._v(" 表示永久重定向，说明请求的资源已经不存在了，需要改用新的URL再次访问。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("302 Moved Permanently")]),t._v(" 表示临时重定向，说明请求的资源还在，但暂时需要用另一个URL来访问。")])]),t._v(" "),v("li",[v("p",[t._v("301和302都会在响应头例使用字段Location，指明后续要跳转的URL，浏览器会自动重定向新的URL。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("304 Not Modified")]),t._v(" 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。")])])]),t._v(" "),v("h3",{attrs:{id:"_4xx"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4xx"}},[t._v("#")]),t._v(" 4XX")]),t._v(" "),v("ul",[v("li",[t._v("4XX 类装填码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。")]),t._v(" "),v("li",[v("strong",[t._v("400 Bad Request")]),t._v(" 表示客户端请求的报文有错误，但只是个笼统的错误。")]),t._v(" "),v("li",[v("strong",[t._v("403 Forbidden")]),t._v(" 表示服务器禁止访问资源，并不是客户端的请求出错。")]),t._v(" "),v("li",[v("strong",[t._v("404 Not Found")]),t._v(" 表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。")])]),t._v(" "),v("h3",{attrs:{id:"_5xx"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5xx"}},[t._v("#")]),t._v(" 5XX")]),t._v(" "),v("ul",[v("li",[t._v("5XX 类状态码表示客户端请求报文正确，但是服务器内部发生了错误，属于服务器端的错误码。")]),t._v(" "),v("li",[v("strong",[t._v("500 Internal Server Error")]),t._v(" 与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。")]),t._v(" "),v("li",[v("strong",[t._v("501 Not Inplemented")]),t._v(" 表示客户端请求的功能还不支持，类似于“即将开业，敬请期待”的意思。")]),t._v(" "),v("li",[v("strong",[t._v("502 Bad Gateway")]),t._v(" 通常是服务器作为网关或代理时返回错误的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。")]),t._v(" "),v("li",[v("strong",[t._v("503 Service Unavailable")]),t._v(" 表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，轻稍后重试”。")])]),t._v(" "),v("h2",{attrs:{id:"_3-http常见的字段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-http常见的字段"}},[t._v("#")]),t._v(" 3. HTTP常见的字段")]),t._v(" "),v("h3",{attrs:{id:"host"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#host"}},[t._v("#")]),t._v(" Host")]),t._v(" "),v("p",[t._v("客户端发送请求时，用来指定服务器的域名。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/fb86d6fd-e6bd-41cf-aece-fed0037dcf81-3807603.jpg",alt:"image"}})]),t._v(" "),v("p",[t._v("有了Host字段，就可以将请求发往 同一台 服务器上的不同网站。")]),t._v(" "),v("h3",{attrs:{id:"content-length-字段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#content-length-字段"}},[t._v("#")]),t._v(" Content-Length 字段")]),t._v(" "),v("p",[t._v("服务器在返回数据时，会有Content-Length字段，表明本次回应的数据长度。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://api2.mubu.com/v3/document_image/2ca4f141-26f2-48bf-a4e7-6e718db6b056-3807603.jpg",alt:"image"}})]),t._v(" "),v("p",[t._v("Content-Length: 1000")]),t._v(" "),v("p",[t._v("如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。")]),t._v(" "),v("h3",{attrs:{id:"connection-字段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#connection-字段"}},[t._v("#")]),t._v(" Connection 字段")]),t._v(" "),v("p",[t._v("Connection字段最常用于客户端要求服务器使用TCP持久连接，以便其他请求复用。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://src.zk123.top//md/e76e6254-5918-4759-a25e-6b0f33ca9968-3807603.jpg",alt:"image"}})]),t._v(" "),v("p",[t._v("HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive。")]),t._v(" "),v("p",[t._v("一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。")]),t._v(" "),v("h3",{attrs:{id:"content-type字段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#content-type字段"}},[t._v("#")]),t._v(" Content-Type字段")]),t._v(" "),v("p",[t._v("用于服务器回应时，告诉客户端，本次数据是什么格式。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://src.zk123.top//md/70955d3f-0d65-4e0c-afe7-dbbdbcc4fe59-3807603.jpg",alt:"image"}})]),t._v(" "),v("p",[t._v("Content-Type: text/html; charset=utf-8")]),t._v(" "),v("p",[t._v("上面的类型表示，发送的是网页，而且编码时UTF-8")]),t._v(" "),v("p",[t._v("客户端请求时，可以使用Accept字段声明自己可以接受那些数据格式。")]),t._v(" "),v("p",[t._v('Accept："/"       表示可以接受任意格式的数据')]),t._v(" "),v("h3",{attrs:{id:"content-encoding-字段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#content-encoding-字段"}},[t._v("#")]),t._v(" Content-Encoding 字段")]),t._v(" "),v("p",[t._v("说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://src.zk123.top//md/e55a7e13-db1f-4307-9b91-39c430d196cd-3807603.jpg",alt:"image"}})]),t._v(" "),v("p",[t._v("Content-Encoding: gzip")]),t._v(" "),v("p",[t._v("上面表示服务器返回的数据采用了gzip的方式压缩，告知客户端需要用此方式解压。")]),t._v(" "),v("p",[t._v("客户端在请求时，用Accept-Encoding 字段说明自己可以接受哪些压缩方法。")]),t._v(" "),v("p",[t._v("Accept-Encoding: gzip, deflate")]),t._v(" "),v("h2",{attrs:{id:"_4-get-与-post"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-get-与-post"}},[t._v("#")]),t._v(" 4. Get 与 Post")]),t._v(" "),v("h3",{attrs:{id:"get-与-post-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#get-与-post-的区别"}},[t._v("#")]),t._v(" Get 与 Post 的区别")]),t._v(" "),v("p",[t._v("Get方法的含义是从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。")]),t._v(" "),v("p",[t._v("比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://src.zk123.top//md/e44b25e2-1336-4cb5-8683-bdff28572547-3807603.jpg",alt:"image"}})]),t._v(" "),v("p",[t._v("而Post方法则是相反操作，它向URL指定的资源提交数据，数据就放在报文的body里。")]),t._v(" "),v("p",[t._v("比如，你在我的留言板中留言后提交，浏览器就会执行一次POST请求，把你的留言文字放进报文的body了，然后拼接好请求头，通过TCP协议发送给服务器。")]),t._v(" "),v("h3",{attrs:{id:"安全和幂等"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#安全和幂等"}},[t._v("#")]),t._v(" 安全和幂等")]),t._v(" "),v("p",[t._v("安全：指的是请求方法不会 "),v("strong",[t._v("破坏")]),t._v(" 服务器上的资源。")]),t._v(" "),v("p",[t._v("幂等：指的是多次执行相同的操作，结果都是相同的。")]),t._v(" "),v("p",[t._v("很明显GET方法是安全且幂等的，因为他是只读操作，无论操作多少次数据都是安全的，且每次的结果都是相同的。")]),t._v(" "),v("p",[t._v("POST因为是 "),v("strong",[t._v("新增或提交数据")]),t._v(" 的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以是不幂等的。")]),t._v(" "),v("h2",{attrs:{id:"_5-http特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-http特性"}},[t._v("#")]),t._v(" 5. HTTP特性")]),t._v(" "),v("h3",{attrs:{id:"http的优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http的优点"}},[t._v("#")]),t._v(" HTTP的优点")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("简单")]),t._v(" "),v("ul",[v("li",[t._v("HTTP的基本报文格式就是header+body，头部信息也可以是key-value简单文本的形式，易于理解，降低了学习和使用的门槛。")])])]),t._v(" "),v("li",[v("p",[t._v("灵活，易于扩展")]),t._v(" "),v("ul",[v("li",[t._v("HTTP协议中各类的请求方法、状态码、字头段每个组成要求都允许开发人员自定义和扩充。")]),t._v(" "),v("li",[t._v("HTTP工作在应用层（OSI第七层），它的下层可以随意变化。")]),t._v(" "),v("li",[t._v("HTTPS在HTTP和TCP层之间增加了SSL/TLS安全传输层。")])])]),t._v(" "),v("li",[v("p",[t._v("应用广泛，跨平台")]),t._v(" "),v("ul",[v("li",[t._v("从台式机的浏览器到手机上的各种APP，具有天然的跨平台的优越性。")])])])]),t._v(" "),v("h3",{attrs:{id:"http的缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http的缺点"}},[t._v("#")]),t._v(" HTTP的缺点")]),t._v(" "),v("ul",[v("li",[t._v("1.无状态 双刃剑\n"),v("ul",[v("li",[t._v("无状态的好处：服务器不会去记忆HTTP状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的CPU个内存用来对外提供服务。")]),t._v(" "),v("li",[t._v("无状态的坏处：在完成有关联性的操作时会非常麻烦，例如 登录->添加购物车->下单->结算->支付，这一系列操作都需要知道用户的身份但是服务器不知道这些请求是有关联的，每次都要问一遍身份信息。")]),t._v(" "),v("li",[t._v("对于无状态的问题，解决方案有很多，其中比较简单的是Cookie技术，Cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态。相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的小贴纸，后续客户端请求服务器的时候，带上小贴纸，服务器就能够识别了。")])])])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://src.zk123.top//md/f88819e9-038b-4310-bb8a-5561f03a6d61-3807603.jpg",alt:"image"}})]),t._v(" "),v("ul",[v("li",[t._v("2.明文传输 双刃剑\n"),v("ul",[v("li",[t._v("明文传输意味着传输过程中的信息，是可方便阅读的，可以通过浏览器控制台查看，为调试工作带来了便利。")]),t._v(" "),v("li",[t._v("一些私密信息不适合明文传输。")])])]),t._v(" "),v("li",[t._v("3.不安全\n"),v("ul",[v("li",[t._v("HTTP比较严重的缺点就是不安全")]),t._v(" "),v("li",[t._v("通信使用明文，内容容易被窃听。")]),t._v(" "),v("li",[t._v("不验证通信方的身份，因此可能遭遇伪装。例如访问假的购物网站，被骗钱。")]),t._v(" "),v("li",[t._v("无法证明报文的完整性，所以可能已遭篡改。比如网页上植入垃圾广告。")]),t._v(" "),v("li",[t._v("HTTP的安全问题，可以通过HTTPS的方式解决，也就是通过引入SSL/TLS层，使得在安全上达到极致。")])])])]),t._v(" "),v("h3",{attrs:{id:"http的性能如何"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http的性能如何"}},[t._v("#")]),t._v(" HTTP的性能如何")]),t._v(" "),v("ul",[v("li",[t._v("1.长连接\n"),v("ul",[v("li",[t._v("早期HTTP/1.0性能是一个很大的问题，每发起一次请求，都要新建一次TCP连接(三次握手)，而且是串行请求，做了无用的TCP连接和断开，增加了通信开销。")]),t._v(" "),v("li",[t._v("为了解决上述TCP连接问题，HTTP/1.1提出了长连接的通信方式，也叫持久连接。这种方式减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。")]),t._v(" "),v("li",[t._v("持久连接的特点是，只要任意一段没有明确提出断开连接，则保持TCP连接状态。")])])])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://src.zk123.top//md/cadf8fc8-589e-47e3-8e76-8e04305de66d-3807603.jpg",alt:"image"}})]),t._v(" "),v("ul",[v("li",[t._v("管道网络传输\n"),v("ul",[v("li",[t._v("HTTP/1.1采用了长连接的方式，这使得管道网络传输成为了可能。")]),t._v(" "),v("li",[t._v("即可以在同一个TCP连接里，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发送第二个请求，可以减少整体的响应时间。")]),t._v(" "),v("li",[t._v("举例：客户端需要两个资源。以前的做法是，在同一个TCP连接里，先发送A请求，等待服务器做出回应，受到后再发出B请求。管到机制则是允许浏览器同时发出A请求和B请求。")]),t._v(" "),v("li",[t._v("但是服务器还是会按照顺序，先回应A请求，完成后再回应B请求。要是前面回应的特别慢，后面就会有许多请求排队等着，这称为 "),v("strong",[t._v("队头堵塞")]),t._v("。")])])])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://src.zk123.top//md/c1acd50b-3d69-4918-aea1-4dd4d1756bae-3807603.jpg",alt:"image"}})]),t._v(" "),v("ul",[v("li",[t._v("队头堵塞\n"),v("ul",[v("li",[t._v("请求-应答的模式加剧了HTTP的性能问题。")]),t._v(" "),v("li",[t._v("因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，再后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是队头阻塞。")])])])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://src.zk123.top//md/3622b9b6-fae3-4a95-9ace-c7e6a7a5b031-3807603.jpg",alt:"image"}})]),t._v(" "),v("p",[t._v("总之 HTTP/1.1的性能一般般，后续的HTTP/2和HTTP/3就是在优化HTTP的性能。")]),t._v(" "),v("h2",{attrs:{id:"_6-http和https"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-http和https"}},[t._v("#")]),t._v(" 6.HTTP和HTTPS")]),t._v(" "),v("h3",{attrs:{id:"http和https有哪些区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http和https有哪些区别"}},[t._v("#")]),t._v(" HTTP和HTTPS有哪些区别")]),t._v(" "),v("ul",[v("li",[t._v("HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。")]),t._v(" "),v("li",[t._v("HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。")]),t._v(" "),v("li",[t._v("HTTP 的端口号是 80，HTTPS 的端口号是 443。")]),t._v(" "),v("li",[t._v("HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。")])]),t._v(" "),v("h3",{attrs:{id:"https-解决了-http-的哪些问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https-解决了-http-的哪些问题"}},[t._v("#")]),t._v(" HTTPS 解决了 HTTP 的哪些问题？")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://src.zk123.top//md/d7da1cd4-c108-4c82-b3d3-d5eb9422b0f4-3807603.jpg",alt:"image"}})]),t._v(" "),v("ul",[v("li",[t._v("HTTP 由于是明文传输，所以安全上存在以下三个风险：\n"),v("ul",[v("li",[t._v("窃听风险，比如通信链路上可以获取通信内容，用户号容易没。")]),t._v(" "),v("li",[t._v("篡改风险，比如强制入垃圾广告，视觉污染。")]),t._v(" "),v("li",[t._v("冒充风险，比如冒充淘宝网站，用户钱容易没。")])])]),t._v(" "),v("li",[t._v("HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议。可以很好的解决了上述的风险。\n"),v("ul",[v("li",[t._v("信息加密，交互信息无法被窃取")]),t._v(" "),v("li",[t._v("校验机制，无法篡改通信内容，篡改了就不能正常显示")]),t._v(" "),v("li",[t._v("身份证书，证明淘宝是真的淘宝网")])])])]),t._v(" "),v("h3",{attrs:{id:"https-是如何解决上面的三个风险的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https-是如何解决上面的三个风险的"}},[t._v("#")]),t._v(" HTTPS 是如何解决上面的三个风险的？")]),t._v(" "),v("ul",[v("li",[t._v("1.混合加密\n"),v("ul",[v("li",[t._v("通过混合加密的方式可以保证信息的机密性，解决了窃听的风险。")]),t._v(" "),v("li",[v("img",{attrs:{src:"https://src.zk123.top//md/29e40c30-89c7-4993-895b-7f609a8471ee-3807603.jpg",alt:"image"}})]),t._v(" "),v("li",[t._v("HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：\n"),v("ul",[v("li",[t._v("在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。")]),t._v(" "),v("li",[t._v("在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。")])])]),t._v(" "),v("li",[t._v("采用「混合加密」的方式的原因：\n"),v("ul",[v("li",[t._v("对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。")]),t._v(" "),v("li",[t._v("非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。")])])])])]),t._v(" "),v("li",[t._v("2.摘要算法\n"),v("ul",[v("li",[t._v("摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。")]),t._v(" "),v("li",[v("img",{attrs:{src:"https://src.zk123.top//md/38d322df-4b90-47ae-abb0-7523a31c184f-3807603.jpg",alt:"image"}})]),t._v(" "),v("li",[t._v("客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同发送")]),t._v(" "),v("li",[t._v("加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据是完整的。")])])]),t._v(" "),v("li",[t._v("3.数字证书\n"),v("ul",[v("li",[t._v("客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。")]),t._v(" "),v("li",[t._v("如何保证公钥不被篡改和信任度？\n"),v("ul",[v("li",[t._v("需要借助第三方权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。")]),t._v(" "),v("li",[v("img",{attrs:{src:"https://src.zk123.top//md/ce038932-2c11-4001-97e7-4bbc1aecda13-3807603.jpg",alt:"image"}})])])]),t._v(" "),v("li",[t._v("通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。")])])])]),t._v(" "),v("h3",{attrs:{id:"https-是如何建立连接的-其间交互了什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https-是如何建立连接的-其间交互了什么"}},[t._v("#")]),t._v(" HTTPS 是如何建立连接的？其间交互了什么？")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("SSL/TLS 协议基本流程：")]),t._v(" "),v("ul",[v("li",[t._v("客户端向服务器索要并验证服务器的公钥。")]),t._v(" "),v("li",[t._v("双方协商生产「会话秘钥」。")]),t._v(" "),v("li",[t._v("双方采用「会话秘钥」进行加密通信。")])])]),t._v(" "),v("li",[v("p",[t._v("前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。SSL/TLS 的「握手阶段」涉及四次通信，可见下图：")])]),t._v(" "),v("li",[v("p",[v("img",{attrs:{src:"https://src.zk123.top//md/51b0a723-055b-421e-b331-23eeca2ab66a-3807603.jpg",alt:"image"}})])]),t._v(" "),v("li",[v("p",[t._v("SSL/TLS 协议建立的详细流程：")]),t._v(" "),v("ul",[v("li",[t._v("1.ClientHello\n"),v("ul",[v("li",[t._v("首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。")]),t._v(" "),v("li",[t._v("在这一步，客户端主要向服务器发送以下信息：\n"),v("ul",[v("li",[t._v("（1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。")]),t._v(" "),v("li",[t._v("（2）客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。")]),t._v(" "),v("li",[t._v("（3）客户端支持的密码套件列表，如 RSA 加密算法。")])])])])]),t._v(" "),v("li",[t._v("2.SeverHello\n"),v("ul",[v("li",[t._v("服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：\n"),v("ul",[v("li",[t._v("（1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。")]),t._v(" "),v("li",[t._v("（2）服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。")]),t._v(" "),v("li",[t._v("（3）确认的密码套件列表，如 RSA 加密算法。")]),t._v(" "),v("li",[t._v("（4）服务器的数字证书。")])])])])]),t._v(" "),v("li",[t._v("3.客户端回应\n"),v("ul",[v("li",[t._v("客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。")]),t._v(" "),v("li",[t._v("如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：\n"),v("ul",[v("li",[t._v("1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。")]),t._v(" "),v("li",[t._v("（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。")]),t._v(" "),v("li",[t._v("（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。")])])]),t._v(" "),v("li",[t._v("上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。")])])]),t._v(" "),v("li",[t._v("4.服务器的最后回应\n"),v("ul",[v("li",[t._v("服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：\n"),v("ul",[v("li",[t._v("（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。")]),t._v(" "),v("li",[t._v("（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。")]),t._v(" "),v("li",[t._v("至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。")])])])])])])])]),t._v(" "),v("h3",{attrs:{id:"http-1-1、http-2、http-3-演变"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1、http-2、http-3-演变"}},[t._v("#")]),t._v(" HTTP/1.1、HTTP/2、HTTP/3 演变")]),t._v(" "),v("ul",[v("li",[t._v("HTTP/1.1 相比 HTTP/1.0 提高了什么性能？")]),t._v(" "),v("li",[t._v("HTTP/1.1 相比 HTTP/1.0 性能上的改进：\n"),v("ul",[v("li",[t._v("使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。")]),t._v(" "),v("li",[t._v("支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。")])])]),t._v(" "),v("li",[t._v("HTTP/1.1 还是有性能瓶颈:")]),t._v(" "),v("li",[t._v("请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；")]),t._v(" "),v("li",[t._v("发送冗长的首部。每次互相发送相同的首部造成的浪费较多；")]),t._v(" "),v("li",[t._v("服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞")]),t._v(" "),v("li",[t._v("没有请求优先级控制；")]),t._v(" "),v("li",[t._v("请求只能从客户端开始，服务器只能被动响应。")]),t._v(" "),v("li",[t._v("上面的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？\n"),v("ul",[v("li",[t._v("1.头部压缩\n"),v("ul",[v("li",[t._v("HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。")]),t._v(" "),v("li",[t._v("这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。")])])]),t._v(" "),v("li",[t._v("2.二进制格式")]),t._v(" "),v("li",[t._v("HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式。")]),t._v(" "),v("li",[t._v("头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。")]),t._v(" "),v("li",[v("img",{attrs:{src:"https://src.zk123.top//md/8ce9492c-29ff-4266-859c-bd7e3db9b9dd-3807603.jpg",alt:"image"}})]),t._v(" "),v("li",[t._v("3.数据流\n"),v("ul",[v("li",[t._v("HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。")]),t._v(" "),v("li",[t._v("每个请求或回应的所有数据包，称为一个数据流（Stream）。")]),t._v(" "),v("li",[t._v("每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数")]),t._v(" "),v("li",[t._v("客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。")]),t._v(" "),v("li",[v("img",{attrs:{src:"https://src.zk123.top//md/01b1fb6c-09fc-4d4e-9ae6-177e5470c8ae-3807603.jpg",alt:"image"}})])])]),t._v(" "),v("li",[t._v("4.多路复用\n"),v("ul",[v("li",[t._v("HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。")]),t._v(" "),v("li",[t._v("移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。")]),t._v(" "),v("li",[t._v("举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。")]),t._v(" "),v("li",[v("img",{attrs:{src:"https://src.zk123.top//md/0713be3f-3b27-4908-ae41-9e22af7c6acd-3807603.jpg",alt:"image"}})])])]),t._v(" "),v("li",[t._v("5.服务器推送\n"),v("ul",[v("li",[t._v("HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。")]),t._v(" "),v("li",[t._v("举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。")])])])])]),t._v(" "),v("li",[t._v("HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？\n"),v("ul",[v("li",[t._v("HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。\n"),v("ul",[v("li",[t._v("HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了")]),t._v(" "),v("li",[t._v("HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。")])])]),t._v(" "),v("li",[t._v("这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！")]),t._v(" "),v("li",[v("img",{attrs:{src:"https://src.zk123.top//md/e2dd1349-b4ed-4ef8-8095-a2b5501252dc-3807603.jpg",alt:"image"}})]),t._v(" "),v("li",[t._v("UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。")]),t._v(" "),v("li",[v("img",{attrs:{src:"https://src.zk123.top//md/4947332d-5377-44e3-b25c-a52622f51dc5-3807603.jpg",alt:"image"}}),t._v(" "),v("ul",[v("li",[t._v("QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。")]),t._v(" "),v("li",[t._v("TL3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack。")]),t._v(" "),v("li",[t._v("HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复用的协议。")]),t._v(" "),v("li",[t._v("QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以 HTTP/3 现在普及的进度非常的缓慢。")])])])])])])])}),[],!1,null,null,null);_.default=l.exports}}]);